{{define "object.redis.read"}}
{{$obj := .}}
{{$primaryField := $obj.PrimaryField}}
//! redis model read
func (m *_{{$obj.Name}}RedisMgr) FindOne(unique Unique) (interface{}, error) {
	if relation := unique.UKRelation(); relation != nil {
		str, err := relation.FindOne(unique.Key())
		if err != nil {
			return "", err
		}
		{{- if $primaryField.IsNeedTransform}}
			var val {{$primaryField.GetTransform.TypeOrigin}}
			if err := m.StringScan(str, &val); err != nil {
				return nil, err
			}
			return {{- printf $primaryField.GetTransform.ConvertTo "val"}}, nil
		{{- else}}
			var val {{$primaryField.GetType}}
			if err := m.StringScan(str, &val); err != nil {
				return nil, err
			}
			return val, nil
		{{- end}}
	}
	return nil, fmt.Errorf("unique none relation.")
}

func (m *_{{$obj.Name}}RedisMgr) FindOneFetch(unique Unique) (*{{$obj.Name}}, error) {
	v, err := m.FindOne(unique)
	if err != nil {
		return nil, err
	}
	return m.Fetch(v)
}

func (m *_{{$obj.Name}}RedisMgr) Find(index Index) ([]interface{}, error) {
	if relation := index.IDXRelation(); relation != nil {
		strs, err := relation.Find(index.Key())
		if err != nil {
			return nil, err
		}
		results := make([]interface{}, 0, len(strs))
		for _, str := range strs {
			{{- if $primaryField.IsNeedTransform}}
				var val {{$primaryField.GetTransform.TypeOrigin}}
				if err := m.StringScan(str, &val); err != nil {
					return nil, err
				}
				results = append(results, {{- printf $primaryField.GetTransform.ConvertTo "val"}})
			{{- else}}
				var val {{$primaryField.GetType}}
				if err := m.StringScan(str, &val); err != nil {
					return nil, err
				}
				results = append(results, val)
			{{- end}}
		}
		return results, nil
	}
	return nil, fmt.Errorf("index none relation.")
}

func (m *_{{$obj.Name}}RedisMgr) FindFetch(index Index) ([]*{{$obj.Name}}, error) {
	vs, err := m.Find(index)
	if err != nil {
		return nil, err
	}
	return m.FetchBy{{$primaryField.Name}}s(vs)
}

func (m *_{{$obj.Name}}RedisMgr) FindCount(index Index) (int64, error) {
	if relation := index.IDXRelation(); relation != nil {
		strs, err := relation.Find(index.Key())
		if err != nil {
			return 0, err
		}
		return int64(len(strs)), nil
	}
	return 0, fmt.Errorf("index none relation.")
}

func (m *_{{$obj.Name}}RedisMgr) Range(scope Range) ([]interface{}, error) {
	if relation := scope.RNGRelation(); relation != nil {
		strs, err := relation.Range(scope.Key(), scope.Begin(), scope.End())
		if err != nil {
			return nil, err
		}
		results := make([]interface{}, 0, len(strs))
		for _, str := range strs {
			{{- if $primaryField.IsNeedTransform}}
				var val {{$primaryField.GetTransform.TypeOrigin}}
				if err := m.StringScan(str, &val); err != nil {
					return nil, err
				}
				results = append(results, {{- printf $primaryField.GetTransform.ConvertTo "val"}})
			{{- else}}
				var val {{$primaryField.GetType}}
				if err := m.StringScan(str, &val); err != nil {
					return nil, err
				}
				results = append(results, val)
			{{- end}}
		}
		return results, nil
	}
	return nil, fmt.Errorf("range none relation.")
}

func (m *_{{$obj.Name}}RedisMgr) RangeFetch(scope Range) ([]*{{$obj.Name}}, error) {
	vs, err := m.Range(scope)
	if err != nil {
		return nil, err
	}
	return m.FetchBy{{$primaryField.Name}}s(vs)
}

func (m *_{{$obj.Name}}RedisMgr) RangeCount(scope Range) (int64, error) {
	if relation := scope.RNGRelation(); relation != nil {
		strs, err := relation.Range(scope.Key(), scope.Begin(), scope.End())
		if err != nil {
			return 0, err
		}
		return int64(len(strs)), nil
	}
	return 0, fmt.Errorf("range none relation.")
}

func (m *_{{$obj.Name}}RedisMgr) RangeRevert(scope Range) ([]interface{}, error) {
	if relation := scope.RNGRelation(); relation != nil {
		scope.Revert(true)
		strs, err := relation.RangeRevert(scope.Key(), scope.Begin(), scope.End())
		if err != nil {
			return nil, err
		}
		results := make([]interface{}, 0, len(strs))
		for _, str := range strs {
			{{- if $primaryField.IsNeedTransform}}
				var val {{$primaryField.GetTransform.TypeOrigin}}
				if err := m.StringScan(str, &val); err != nil {
					return nil, err
				}
				results = append(results, {{- printf $primaryField.GetTransform.ConvertTo "val"}})
			{{- else}}
				var val {{$primaryField.GetType}}
				if err := m.StringScan(str, &val); err != nil {
					return nil, err
				}
				results = append(results, val)
			{{- end}}
		}
		return results, nil
	}
	return nil, fmt.Errorf("revert range none relation.")
}

func (m *_{{$obj.Name}}RedisMgr) RangeRevertFetch(scope Range) ([]*{{$obj.Name}}, error) {
	vs, err := m.RangeRevert(scope)
	if err != nil {
		return nil, err
	}
	return m.FetchBy{{$primaryField.Name}}s(vs)
}

func (m *_{{$obj.Name}}RedisMgr) Fetch({{$primaryField.Name | camel2name}} interface{}) (*{{$obj.Name}}, error) {
	obj := {{$obj.Name}}Mgr.New{{$obj.Name}}()
	
	pipe := m.BeginPipeline()
	pipe.Exists(keyOfObject(obj, fmt.Sprint({{$primaryField.Name | camel2name}})))
	pipe.HMGet(keyOfObject(obj, fmt.Sprint({{$primaryField.Name | camel2name}}))
	{{- range $i, $field := $obj.Fields -}}	
			  ,"{{$field.Name}}"
	{{- end -}})
	cmds, err := pipe.Exec()
	if err != nil {
		return nil, err
	}

	if b, err := cmds[0].(*redis.BoolCmd).Result(); err == nil {
		if !b {
			return nil, fmt.Errorf("{{$obj.Name}} {{$primaryField.Name}}:(%v) not exist", {{$primaryField.Name | camel2name}})
		}
	}

	strs, err := cmds[1].(*redis.SliceCmd).Result()
	if err != nil {
		return nil, err
	}

	{{- range $i, $field := $obj.Fields}}		
		{{- if $field.IsNeedTransform}}
			{{- if $field.IsNullable }}
				if strs[{{$i}}].(string) == "nil" {
					obj.{{$field.Name}} = nil	
				} else {
					var val{{$i}} {{$field.GetTransform.TypeOrigin}}
					if err := m.StringScan(strs[{{$i}}].(string), &val{{$i}}); err != nil {
						return nil, err
					}
					{{$field.Name}}Value := {{- printf $field.GetTransform.ConvertTo (printf "val%d" $i)}}
					obj.{{$field.Name}} = &{{$field.Name}}Value 
				}				
			{{- else}}
				var val{{$i}} {{$field.GetTransform.TypeOrigin}}
				if err := m.StringScan(strs[{{$i}}].(string), &val{{$i}}); err != nil {
					return nil, err
				}
				obj.{{$field.Name}} = {{- printf $field.GetTransform.ConvertTo (printf "val%d" $i)}}
			{{- end}}
		{{- else}}
			if err := m.StringScan(strs[{{$i}}].(string), &obj.{{$field.Name}}); err != nil {
				return nil, err
			}
		{{- end}}
	{{- end}}
	return obj, nil
}

func (m *_{{$obj.Name}}RedisMgr) FetchBy{{$primaryField.Name}}s({{$primaryField.Name | camel2name}}s []interface{}) ([]*{{$obj.Name}}, error) {
	objs := make([]*{{$obj.Name}}, 0, len({{$primaryField.Name | camel2name}}s))
	pipe := m.BeginPipeline()
	obj := {{$obj.Name}}Mgr.New{{$obj.Name}}()
	for _, id := range {{$primaryField.Name | camel2name}}s {		
		pipe.Exists(keyOfObject(obj, fmt.Sprint(id)))
		pipe.HMGet(keyOfObject(obj, fmt.Sprint(id))
		{{- range $i, $field := $obj.Fields -}}	
			  ,"{{$field.Name}}"
		{{- end -}})
	}
	cmds, err := pipe.Exec()
	if err != nil {
		return nil, err
	}
	for i := 0; i < len({{$primaryField.Name | camel2name}}s); i++ {
		if b, err := cmds[2*i].(*redis.BoolCmd).Result(); err == nil {
			if !b {
				return nil, fmt.Errorf("{{$obj.Name}} {{$primaryField.Name}}:(%v) not exist", {{$primaryField.Name | camel2name}}s[i])
			}
		}

		strs, err := cmds[2*i+1].(*redis.SliceCmd).Result()
		if err != nil {
			return nil, err
		}

		obj := {{$obj.Name}}Mgr.New{{$obj.Name}}()
		{{- range $i, $field := $obj.Fields}}		
			{{- if $field.IsNeedTransform}}
				{{- if $field.IsNullable }}
					if strs[{{$i}}].(string) == "nil" {
						obj.{{$field.Name}} = nil	
					} else {
						var val{{$i}} {{$field.GetTransform.TypeOrigin}}
						if err := m.StringScan(strs[{{$i}}].(string), &val{{$i}}); err != nil {
							return nil, err
						}
						{{$field.Name}}Value := {{- printf $field.GetTransform.ConvertTo (printf "val%d" $i)}}
						obj.{{$field.Name}} = &{{$field.Name}}Value 
					}				
				{{- else}}
					var val{{$i}} {{$field.GetTransform.TypeOrigin}}
					if err := m.StringScan(strs[{{$i}}].(string), &val{{$i}}); err != nil {
						return nil, err
					}
					obj.{{$field.Name}} = {{- printf $field.GetTransform.ConvertTo (printf "val%d" $i)}}
				{{- end}}
			{{- else}}
				if err := m.StringScan(strs[{{$i}}].(string), &obj.{{$field.Name}}); err != nil {
					return nil, err
				}
			{{- end}}
		{{- end}}
		objs = append(objs, obj)
	}
	return objs, nil
}

{{end}}
